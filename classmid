import cvclass
import cv2 as cv
import numpy as np
video = cv.VideoCapture(0)
import math
if not video.isOpened():
    print('Error')
while True:
    tester,frame=video.read()
    frame_proc=cvclass.cvcol(frame,pathing=True,gray=True)
#    frame_proc.dialate(10)
    frame_proc.erode(10)
#    frame_proc.dialate(27)
    frame_proc.bluredlines()
#   test code for skeletonization alg from https://opencvpython.blogspot.com/2012/05/skeletonization-using-opencv-python.html
    size = np.size(frame_proc.img)
    img = frame_proc.ret()
#imported algorithm 
    '''
    skel=np.zeros( img.shape,np.uint8)
    ret,img=cv.threshold(img,127,255,0)
    elmtn=cv.getStructuringElement(cv.MORPH_CROSS,(3,3))
    finish=False
    while not finish:
        eroded=cv.erode(img,element)
        temp = cv.dilate(eroded,element)
	temp = cv.subtract(img,temp)
	skel = cv.bitwise_or(
    '''

    #cv.imshow('linves',frame_proc.img)
    #frame_proc.img=cv.equalizeHist(frame_proc.img)
    frame_proc.img=cv.Canny(frame_proc.img, 50,100)
   # cv.imshow('lines',frame_proc.img)
    #frame_proc.img *= np.array((0,0,255),np.uint8)
    polygon_points = np.array([[[200, 0], [1000, 0], [1200, 800], [100, 800]]], dtype=np.int32)
    mask = np.zeros((frame_proc.img.shape[0],frame_proc.img.shape[1]),dtype=np.uint8)
    cv.fillPoly(mask, polygon_points, 255)
    frame_proc.img = cv.bitwise_and(frame_proc.img,frame_proc.img,mask=mask)
    lines = cv.HoughLinesP(frame_proc.ret(),rho=1,theta=np.pi/180,threshold=100 ,minLineLength=250,maxLineGap=60)
    frame_proc.img= cv.cvtColor(frame_proc.img, cv.COLOR_GRAY2BGR)
    imag=frame_proc.img
   # imag= cv2.bitwise_and(imag, col_msk)
    cv.imshow('webcam',imag)
#    cv.waitKey(1)
    if lines is None:   
        continue
    i=0
    ptlines=[]
    for line in lines:

        x_i,y_i,x_f,y_f=line[0]
        ptlines.append([x_i,y_i,x_f,y_f])
 #       if i<1:
           # cv.line(imag,(x_i,y_i),(x_f,y_f),(255,0,0),8)
#        elif i<2:
            # cv.line(imag,(x_i,y_i),(x_f,y_f),(0,0,255),8)
        i+=1  
    if len(ptlines)<2:
        continue
    parallel_=[]
    break9=False
    for line0 in ptlines:
        for line1 in ptlines:
            if math.fabs(math.atan(((line0[2]-line0[0])/(line0[3]-line0[1])))-math.atan(((line1[2]-line1[0])/(line1[3]-line1[1]))))<=0.5:
                cv.line(imag,(line0[0],line0[1]),(line0[2],line0[3]),(255,0,0),8)
                cv.line(imag,(line1[0],line1[1]),(line1[2],line1[3]),(0,255,0),8)
                parallel_.append([line0,line1]) 
                break
        if break9:
            break
    avg_x_i=0
    avg_x_f=0
    avg_y_i=0
    avg_y_f=0
    for lines in ptlines:
            avg_x_i+= (lines[0]/(len(ptlines))
            avg_x_f+= (lines[2]/(len(ptlines)) 
            avg_y_i+= (lines[1)/(len(ptlines)
            avg_y_f+= (lines[3])/(len(ptlines))
    cv.line(imag,(avg_x_i,avg_y_i),(avg_x_f,avg_y_f),(0,0,255),7)
    fin_frm=cv.addWeighted(frame,0.6,imag,0.4,0)
    cv.imshow('webbcam',fin_frm)
    cv.waitKey(1)
video.release()
