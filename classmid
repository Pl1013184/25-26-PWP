from flask import Flask
import cvclass
import cv2 as cv
import numpy as np
app=Flask(__name__)
video = cv.VideoCapture(0)
import math
if not video.isOpened():
    print('Error')
def avg_liens(lines):
    xi_avg=0
    yi_avg=0
    xf_avg=0
    yf_avg=0
	for line in lines:
        xi_avg+=line[0]/len(lines)
        yi_avg+=line[1]/len(lines)
        xf_avg+=line[2]/len(lines)
        yf_avg+=line[3]/len(lines)
    return[xi_avg,yi_avg,xf_avg,yf_avg]
def slp(line):
    if line[2]-line[0]==0:
	    return 0
    return (line[3]-line[1])/(line[2]-line[0])
def gen_frames_proc()
	while True:
	    tester,frame=video.read()
	    midline = frame.shape[1]
	    frame_proc=cvclass.cvcol(frame,pathing=True,gray=True)
	#    frame_proc.dialate(10)
	    frame_proc.erode(10)
	#    frame_proc.dialate(27)
	    frame_proc.bluredlines()
	#   test code for skeletonization alg from https://opencvpython.blogspot.com/2012/05/skeletonization-using-opencv-python.html
	    size = np.size(frame_proc.img)
	    img = frame_proc.ret()
	#imported algorithm 
	    '''
	    skel=np.zeros( img.shape,np.uint8)
	    ret,img=cv.threshold(img,127,255,0)
	    elmtn=cv.getStructuringElement(cv.MORPH_CROSS,(3,3))
	    finish=False
	    while not finish:
	        eroded=cv.erode(img,element)
	        temp = cv.dilate(eroded,element)
		temp = cv.subtract(img,temp)
		skel = cv.bitwise_or(
	    '''
	
	    #cv.imshow('linves',frame_proc.img)
	    #frame_proc.img=cv.equalizeHist(frame_proc.img)
	    frame_proc.img=cv.Canny(frame_proc.img, 50,100)
	   # cv.imshow('lines',frame_proc.img)
	    #frame_proc.img *= np.array((0,0,255),np.uint8)
	    polygon_points = np.array([[[200, 0], [1000, 0], [1200, 800], [100, 800]]], dtype=np.int32)
	    mask = np.zeros((frame_proc.img.shape[0],frame_proc.img.shape[1]),dtype=np.uint8)
	    cv.fillPoly(mask, polygon_points, 255)
	    frame_proc.img = cv.bitwise_and(frame_proc.img,frame_proc.img,mask=mask)
	    lines = cv.HoughLinesP(frame_proc.ret(),rho=1,theta=np.pi/180,threshold=100 ,minLineLength=250,maxLineGap=60)
	    frame_proc.img= cv.cvtColor(frame_proc.img, cv.COLOR_GRAY2BGR)
	    imag=frame_proc.img
	   # imag= cv2.bitwise_and(imag, col_msk)
	    #cv.imshow('webcam',imag)
	#    cv.waitKey(1)
	    if lines is None:   
	        continue
	    i=0
	    ptlines=[]
	    for line in lines:
	
	        x_i,y_i,x_f,y_f=line[0]
	        ptlines.append([x_i,y_i,x_f,y_f])
	        i+=1  
	    if len(ptlines)<2:
	        continue
	    parallel_=[]
	    break9=False
	    ''' 
	    for line0 in ptlines:
	        for line1 in ptlines:
	            if line0==line1:
	                continue
	            if math.fabs(math.atan(((line0[2]-line0[0])/(line0[3]-line0[1])))-math.atan(((line1[2]-line1[0])/(line1[3]-line1[1]))))<=0.5:
	                cv.line(imag,(line0[0],line0[1]),(line0[2],line0[3]),(255,0,0),8)
	                cv.line(imag,(line1[0],line1[1]),(line1[2],line1[3]),(0,255,0),8)
	                parallel_.append([line0,line1]) 
	                break
	        if break9:
	            break
	    '''
	    left_lnes=[]
	    right_lnes=[]
	    for line in ptlines:
		    if slp(line)<0:
	            right_lnes.append(line)
	        else:
	            left_lnes.append(line)
	
	    avg_x_i_l=avg_liens(left_lnes)[0]
	    avg_x_f_l=avg_liens(left_lnes)[2]
	    avg_y_i_l=avg_liens(left_lnes)[1]
	    avg_y_f_l=avg_liens(left_lnes)[3]
	    avg_x_i_r=avg_liens(right_lnes)[0]
	    avg_x_f_r=avg_liens(right_lnes)[2]
	    avg_y_i_r=avg_liens(right_lnes)[1]
	    avg_y_f_r=avg_liens(right_lnes)[3]
	    '''
	    for lines in ptlines:
	            avg_x_i+= (lines[0]/(len(ptlines))
	            avg_x_f+= (lines[2]/(len(ptlines)) 
	            avg_y_i+= (lines[1)/(len(ptlines)
	            avg_y_f+= (lines[3])/(len(ptlines))
	            avg_slope+= lines[3]-lines[1]/lines[2]-lines[0]
	    
	    cv.line(imag,(avg_x_i,avg_y_i),(avg_x_f,avg_y_f),(0,0,255),7)
	    '''
	    cv.line(imag,(avg_x_i_l,avg_y_i_l),(avg_x_f_l,avg_y_f_l),(0,0,255),7)
	    cv.line(imag,(avg_x_i_r,avg_y_i_r),(avg_x_f_r,avg_y_f_r),(255,0,0),7)
	    cv.line(imag,((avg_x_i_l+avg_x_i_r)//2,(avg_y_i_l+avg_y_i_r)//2), ((avg_x_f_l+avg_x_f_r)//2,(avg_y_f_l+avg_y_f_r)//2),(0,255,0),7)
	    fin_frm=cv.addWeighted(frame,0.6,imag,0.4,0)
	    #cv.imshow('webbcam',fin_frm)
	    x, img_data = cv2.imencode('.jpg', raw)
	    raw_bytes = img_data.tobytes()
	    yield (b'--frame\r\n'
	      b'Content-Type: image/jpeg\r\n\r\n' + raw_bytes + b'\r\n')
	    cv.waitKey(1)
	video.release()
@app.route('/proc_vid')
def proc_vid():
   return Response(gen_frames_proc(), mimetype='multipart/x-mixed-replace; boundary=frame')

