from flask import Flask,Response
import cvclass
import cv2 as cv
import numpy as np
app=Flask(__name__)
video = cv.VideoCapture(0)
import math
if not video.isOpened():
    print('Error')
def avg_liens(lines):
    xi_avg=0
    yi_avg=0
    xf_avg=0
    yf_avg=0
    for line in lines:
        xi_avg+=line[0]/len(lines)
        yi_avg+=line[1]/len(lines)
        xf_avg+=line[2]/len(lines)
        yf_avg+=line[3]/len(lines)
    return[int(xi_avg),int(yi_avg),int(xf_avg),int(yf_avg)]
def slp(line):
    if math.fabs(line[2]-line[0])-0.001<0:
        return 1000000,0
    return (line[3]-line[1])/(line[2]-line[0]),line[3]-(line[2]*(line[3]-line[1])/(line[2]-line[0]))

def avg_liens_ymxb(lines):
    avg_slope=0
    avg_constant=0
    if len(lines)==0:
        return[0,0]
    for line in lines:
        s,c=slp(line)
        avg_slope+=s
        avg_constant+=c
    return [avg_slope//len(lines),avg_constant//len(lines)]
def raw_vid():
    while True:
        tester,frame=video.read()
        if not tester:
            continue
        encode_param = [int(cv.IMWRITE_JPEG_QUALITY), 50]
        x, img_data = cv.imencode('.jpg', frame,encode_param)
        raw_bytes = img_data.tobytes()
        yield (b'--frame\r\n'
          b'Content-Type: image/jpeg\r\n\r\n' + raw_bytes + b'\r\n')
def gen_frames_proc():
    while True:
        tester,frame=video.read()
        if not tester:
            continue
        midline = frame.shape[1]
        frame_proc=cvclass.cvcol(frame,pathing=True,gray=True)
    #    frame_proc.dialate(10)
        frame_proc.erode()
    #    frame_proc.dialate(27)
        frame_proc.bluredlines()
    #   test code for skeletonization alg from https://opencvpython.blogspot.com/2012/05/skeletonization-using-opencv-python.html
        size = np.size(frame_proc.img)
        img = frame_proc.ret()
    #imported algorithm 
        '''
        skel=np.zeros( img.shape,np.uint8)
        ret,img=cv.threshold(img,127,255,0)
        elmtn=cv.getStructuringElement(cv.MORPH_CROSS,(3,3))
        finish=False
        while not finish:
            eroded=cv.erode(img,element)
            temp = cv.dilate(eroded,element)
            temp = cv.subtract(img,temp)
            skel = cv.bitwise_or(
        '''
    
        #cv.imshow('linves',frame_proc.img)
        #frame_proc.img=cv.equalizeHist(frame_proc.img)
        frame_proc.img=cv.Canny(frame_proc.img, 50,100)
       # cv.imshow('lines',frame_proc.img)
        #frame_proc.img *= np.array((0,0,255),np.uint8)
        polygon_points = np.array([[[200, 0], [1000, 0], [1200, 800], [100, 800]]], dtype=np.int32)
        mask = np.zeros((frame_proc.img.shape[0],frame_proc.img.shape[1]),dtype=np.uint8)
        cv.fillPoly(mask, polygon_points, 255)
        frame_proc.img = cv.bitwise_and(frame_proc.img,frame_proc.img,mask=mask)
        lines = cv.HoughLinesP(frame_proc.ret(),rho=1,theta=np.pi/180,threshold=100 ,minLineLength=200,maxLineGap=60)
        frame_proc.img= cv.cvtColor(frame_proc.img, cv.COLOR_GRAY2BGR)
        imag=frame_proc.img
       # imag= cv2.bitwise_and(imag, col_msk)
        #cv.imshow('webcam',imag)
        #cv.waitKey(1)
        if lines is None:   
            continue
        i=0
        ptlines=[]
        for line in lines:
            x_i,y_i,x_f,y_f=line[0]
            ptlines.append([x_i,y_i,x_f,y_f])
            i+=1  
        if len(ptlines)<2:
            continue
        parallel_=[]
        break9=False
        ''' 
        for line0 in ptlines:
            for line1 in ptlines:
                if line0==line1:
                    continue
                if math.fabs(math.atan(((line0[2]-line0[0])/(line0[3]-line0[1])))-math.atan(((line1[2]-line1[0])/(line1[3]-line1[1]))))<=0.5:
                    cv.line(imag,(line0[0],line0[1]),(line0[2],line0[3]),(255,0,0),8)
                    cv.line(imag,(line1[0],line1[1]),(line1[2],line1[3]),(0,255,0),8)
                    parallel_.append([line0,line1]) 
                    break
            if break9:
                break
        '''
        left_lnes=[]
        right_lnes=[]
        for line in ptlines:
            slope,constant=slp(line)
            if slope is None:
                if line[0]<frame.shape[1]/2:
                    left_lnes.append(line)
                else:
                    right_lnes.append(line)
            elif slope<0:
                right_lnes.append(line)
            else:
                left_lnes.append(line)
            
        avg_x_i_l=avg_liens(left_lnes)[0]
        avg_x_f_l=avg_liens(left_lnes)[2]
        avg_y_i_l=avg_liens(left_lnes)[1]
        avg_y_f_l=avg_liens(left_lnes)[3]
        avg_x_i_r=avg_liens(right_lnes)[0]
        avg_x_f_r=avg_liens(right_lnes)[2]
        avg_y_i_r=avg_liens(right_lnes)[1]
        avg_y_f_r=avg_liens(right_lnes)[3]
        lft_s=avg_liens_ymxb(right_lnes)[0]
        lft_c=avg_liens_ymxb(right_lnes)[1]
        r_s=avg_liens_ymxb(left_lnes)[0]
        r_c=avg_liens_ymxb(left_lnes)[1]
        a_s=(r_s+lft_s)/2
        a_c=(lft_c+r_c)//2
        '''
        for lines in ptlines:
                avg_x_i+= int(lines[0]/(len(ptlines))
                avg_x_f+=int(lines[2]/(len(ptlines)) 
                avg_y_i+= int(lines[1/(len(ptlines)
                avg_y_f+= int(lines[3]/(len(ptlines))
                avg_slope+= int(lines[3]-lines[1]/lines[2]-lines[0])
        
        cv.line(imag,(avg_x_i,avg_y_i),(avg_x_f,avg_y_f),(0,0,255),7)
        
        cv.line(imag,(imag.shape[0]//2,imag.shape[0]*int(a_s)+a_c),((avg_x_f_l+avg_x_f_r)//2,(avg_x_f_l+avg_x_f_r)//2*int(a_s)+a_c),(255,255,0),7)
        '''
        if not math.fabs(a_s)-0.001>0 and a_s != None:
            y_i=imag.shape[0]
            y_f=int(imag.shape[0]*0.1)
            try:
                x_i=int((y_i-a_c) // a_s)
                x_f = int((y_f - a_c) // a_s)
                cv.line(imag,((avg_x_i_l+avg_x_i_r)//2,(avg_y_i_l+avg_y_i_r)//2), ((avg_x_f_l+avg_x_f_r)//2,(avg_y_f_l+avg_y_f_r)//2),(0,255,0),7)
            except:
                cv.line(imag, ((avg_x_i_l+avg_x_i_r)//2, y_i), ((avg_x_f_l+avg_x_f_r)//2, y_f), (0,255,0), 7)
        else:
           #print('here')
           cv.line(imag,((avg_x_i_l+avg_x_i_r)//2,int(frame.shape[0]*0.8)), ((avg_x_f_l+avg_x_f_r)//2,(avg_y_f_l+avg_y_f_r)//2),(0,255,0),7)
           #break
        cv.line(imag,(avg_x_i_l,avg_y_i_l),(avg_x_f_l,avg_y_f_l),(0,0,255),7)
        cv.line(imag,(avg_x_i_r,avg_y_i_r),(avg_x_f_r,avg_y_f_r),(255,0,0),7)
        #cv.line(imag,(avg_x_i_l+avg_x_i_r)//2,(avg_y_i_l+avg_y_i_r)//2), ((avg_x_f_l+avg_x_f_r)//2,(avg_y_f_l+avg_y_f_r)//2),(0,255,0),7)
        fin_frm=cv.addWeighted(frame,0.6,imag,0.4,0)
        #cv.imshow('webbcam',fin_frm)
        encode_param = [int(cv.IMWRITE_JPEG_QUALITY), 50]
        x, img_data = cv.imencode('.jpg', fin_frm,encode_param)
        raw_bytes = img_data.tobytes()
        yield (b'--frame\r\n'
          b'Content-Type: image/jpeg\r\n\r\n' + raw_bytes + b'\r\n')
        cv.waitKey(1)
    video.release()

@app.route('/proc_vid')
def proc_vid():
   return Response(gen_frames_proc(), mimetype='multipart/x-mixed-replace; boundary=frame')
@app.route('/vid')
def vid():
   return Response(raw_vid(), mimetype='multipart/x-mixed-replace; boundary=frame')
app.run(host='0.0.0.0', port=5000, threaded=True)
